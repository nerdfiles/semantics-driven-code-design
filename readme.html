<h1 id="the-metaphysics-of-css">The Metaphysics of CSS</h1>
<p>Consider these <a href="https://krasimir.github.io/organic-css/">mixin</a> names</p>
<pre><code>.A-rolodex--container__self__ {}
.TYPE-BLOCK--ELEMENT__MODE__ {}
.TYPE-BLOCK--ELEMENT__MODE__ {
    @include thing;
    @include thing-atom-1;
    @include thing-atom-2;
    @include thing-atom-3;
    @include thing-atom-4;
}</code></pre>
<p>As Derrida asserts, the metaphysics of presence is unavoidable, so our purpose here is to ensure systematic tasks in processing stylesheets is metacomputational.</p>
<h2 id="the-opposition">The opposition</h2>
<p>A problem that is apparent today is the CSS “utility” framework approach which introduces names such as the following:</p>
<pre><code>.\(F\)\(PARAM\) {}
.G\:PARAM {}</code></pre>
<p>Generally “utility” frameworks attempt to preserve levels of and for a syntax tree such that parameterization is combined with space-delimited name scheme where prefixes are matched according to their need at the given level expressed in the non-standard metacomputational name’s immanent structure for presentation.</p>
<p>Unfortunately, what happens with this naming pattern is that the name strings within the class attribute value are used as if they were definite descriptions and it is expected of the developer to manage the cascade in a hierarchical model. Quickly this becomes unscalable as complexity of the interface grows over time. What of the temporalization of the interface is lost as developers change hands or debugging becomes an issue. Our task is to make such temporalization explicit within a placeholder of the naming schema. Often numbers are used in a sequence to designate the temporalization in an ad hoc manner, but we want a specific placeholder formation such that we can seek within subbranched prefix hash tree for the relevant style properties to be made available in the mixin ensemble which determines the how the style will play out in the cascade.</p>
<p>Ideally only one mereologically complex name as sentence-subject will appear for the elemental name, rather than the developer takes some effort to describe the component on-the-fly. Names possess power and planning implications: was it poorly em-powered or poorly planned? “Utility” classes indicate overpowering of other names at the same level of description while when combined with a “No UML” approach, developers are encouraged to design-as-they-go. Such practice should be avoided as it results in low understandability in the design as it is regarded between collaborating developers.</p>
<p>From <a href="https://web.engr.oregonstate.edu/~erwig/papers/SemanticDSLDesign-12.pdf" title="Semantics-Driven DSL Design. Martin Erwig and Eric Walkingshaw. School of EECS, Oregon State University, USA.">Semantics-driven DSL Design</a>:</p>
<pre><code>week52 :: Cal String
week52 = D Dec 30 :-&gt; (T 8 0 :-&gt; &quot;Work&quot;) :&amp;: D Dec 31 :-&gt; (T 22 0 :-&gt; &quot;Party&quot;)</code></pre>
<p>Organic SASS analogues:</p>
<pre><code>.state-(start)--[start]__simulator-running__ {}
.state-(simulator-running)--[pause]__simulator-pause|do__ {}</code></pre>
<p>Compare with yUML implicatures:</p>
<pre><code>(start)[Start]-&gt;(Simulator running)
(Simulator running)[Pause]-&gt;(Simulator paused|do / wait)
...</code></pre>
<p>We don’t have to worry about <code>:&amp;:</code> since it represents something like two sibling <code>&lt;div&gt;</code>s standing side-by-side in the DOM.</p>
